import{_ as s,c as i,o as a,a3 as t,cH as l,cI as n,cJ as e,cK as h,cL as p}from"./chunks/framework.Di-rThNJ.js";const F=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"docs/method/dp/七大原则.md","filePath":"docs/method/dp/七大原则.md","lastUpdated":1715595015000}'),r={name:"docs/method/dp/七大原则.md"},o=t('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><h2 id="七大原则" tabindex="-1">七大原则 <a class="header-anchor" href="#七大原则" aria-label="Permalink to &quot;七大原则&quot;">​</a></h2><p>这些原则主要的目的是提高代码的<strong>可维护性</strong>、<strong>可复用性</strong>和<strong>可扩展性</strong></p><h3 id="单一职责原则-srp" tabindex="-1"><strong>单一职责原则 (SRP)</strong>: <a class="header-anchor" href="#单一职责原则-srp" aria-label="Permalink to &quot;**单一职责原则 (SRP)**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: 一个类或模块应该有且仅有一个改变的理由。换句话说，<strong>一个类应负责一项明确的功能或职责</strong>。</p></li><li><p><strong>应用</strong>: 通过拆分复杂的类为多个小类，每个类专注于单一职责，这样修改一处功能时，不会影响到其他职责。</p></li></ul><h3 id="开放封闭原则-ocp" tabindex="-1"><strong>开放封闭原则 (OCP )</strong>: <a class="header-anchor" href="#开放封闭原则-ocp" aria-label="Permalink to &quot;**开放封闭原则 (OCP )**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: 软件实体（类、模块、函数等）应该对<strong>扩展开放</strong>，对<strong>修改关闭</strong>。这意味着可以在不修改原有代码的情况下进行功能扩展。</p></li><li><p><strong>应用</strong>: 通过抽象和接口设计，使得新增功能可以通过增加新的类来实现，而不是修改现有类。</p></li></ul><h3 id="里氏替换原则-lsp" tabindex="-1"><strong>里氏替换原则 (LSP)</strong>: <a class="header-anchor" href="#里氏替换原则-lsp" aria-label="Permalink to &quot;**里氏替换原则 (LSP)**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: 子类应当能够替换它们的基类并在软件中正确工作，而不会引起错误或异常行为。</p></li><li><p><strong>应用</strong>: 确保子类不会改变父类的预期行为，保证多态性的安全使用。</p></li></ul><h3 id="依赖倒转原则-dip" tabindex="-1"><strong>依赖倒转原则 (DIP)</strong>: <a class="header-anchor" href="#依赖倒转原则-dip" aria-label="Permalink to &quot;**依赖倒转原则 (DIP)**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: 高层模块不应依赖于低层模块，二者都应依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p></li><li><p><strong>应用</strong>: 通过面向接口编程，而不是具体类，使得系统更加灵活，易于测试和维护。</p></li></ul><h3 id="接口隔离原则-isp" tabindex="-1"><strong>接口隔离原则 (ISP)</strong>: <a class="header-anchor" href="#接口隔离原则-isp" aria-label="Permalink to &quot;**接口隔离原则 (ISP)**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: <strong>客户端不应该被迫依赖它不使用的方法</strong>。接口应该尽可能细化，以满足不同客户端的具体需求。</p></li><li><p><strong>应用</strong>: 将大接口拆分为多个小接口，每个接口服务于一个特定的客户类群。</p></li></ul><h3 id="迪米特法则-lod-或-最少知识原则" tabindex="-1"><strong>迪米特法则 (LoD )</strong> 或 <strong>最少知识原则</strong>: <a class="header-anchor" href="#迪米特法则-lod-或-最少知识原则" aria-label="Permalink to &quot;**迪米特法则 (LoD )** 或 **最少知识原则**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: 一个对象应当对其他对象有最少的了解。也就是说，<strong>尽量减少对象之间的交互，仅通过接口通信</strong>。</p></li><li><p><strong>应用</strong>: 减少类之间的耦合，每个类只和它的朋友（直接的朋友或通过参数传递的对象）交流，不和朋友的朋友交谈。</p></li></ul><h3 id="合成-聚合复用原则-carp" tabindex="-1"><strong>合成/聚合复用原则 (CARP )</strong>: <a class="header-anchor" href="#合成-聚合复用原则-carp" aria-label="Permalink to &quot;**合成/聚合复用原则 (CARP )**:&quot;">​</a></h3><ul><li><p><strong>概念</strong>: 尽量使用对象组合，而不是类继承来达到复用的目的。即“<strong>要尽量使用对象组合，而不是类继承</strong>”。</p></li><li><p><strong>应用</strong>: 优先考虑对象的组合（聚合或合成），这样可以更灵活地在运行时改变对象的行为，同时避免继承的复杂性。</p></li></ul><h2 id="uml类图" tabindex="-1">UML类图 <a class="header-anchor" href="#uml类图" aria-label="Permalink to &quot;UML类图&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>此文档图数据来源于《大话数设计模式》</p></div><p><img src="'+l+'" alt="UML"></p><h3 id="基本构成元素" tabindex="-1">基本构成元素 <a class="header-anchor" href="#基本构成元素" aria-label="Permalink to &quot;基本构成元素&quot;">​</a></h3><ol><li><strong>类（Class）</strong>: 通常表示为一个矩形，分为三部分： <ul><li>类名：位于顶部。</li><li>属性（Attributes）：位于中部，可标注访问修饰符（如public, private, protected等）。</li><li>操作（Operations/Methods）：位于底部，同样可标注访问修饰符。</li></ul></li><li><strong>接口（Interface）</strong>: 与类类似，但顶部有&lt;&gt;标记以区分，强调它只包含操作定义，不包含属性。</li><li><strong>包（Package）</strong>: 用于组织和分组类和接口，通常用一个文件夹图标表示。</li></ol><p><img src="'+n+`" alt="类和接口"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IFly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="关系" tabindex="-1">关系 <a class="header-anchor" href="#关系" aria-label="Permalink to &quot;关系&quot;">​</a></h3><ul><li><p><strong>依赖关系（Dependency）</strong>: 用虚线箭头表示，表明一个类依赖于另一个类的定义，通常是由于方法参数或局部变量的使用。</p></li><li><p><strong>关联关系（Association）</strong>: 用实线箭头表示类之间的结构关系。可以是单向或多向，可带有角色名和多重性标记（如1..*表示一对多关系）。</p></li></ul><p><img src="`+e+`" alt="依赖和关联"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//关联关系</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Penguin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bird</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //在企鹅Penguin中，引用了气候Climate对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Climate climate;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//依赖关系</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Metabolism</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Oxygen </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oxygen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,Water </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">water</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><p><strong>聚合关系（Aggregation）</strong>: 一种特殊的关联，表示整体与部分的关系，用空心菱形的实线箭头表示，强调部分可以独立存在。</p></li><li><p><strong>组合关系（Composition）</strong>: 也是整体与部分的关系，但部分不能独立于整体存在，用实心菱形的实线箭头表示。</p></li></ul><p><img src="`+h+`" alt="聚合和组合"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//聚合关系</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WideGooseAggregate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //在雁群WideGooseAggregate中有大雁数组对象arrayWideGoose</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WideGoose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] arrayWideGoose;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//组合关系</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bird</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //在Bird类中声明一个翅膀Wing和对象wing</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Wing wing;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //初始化时候，实例化翅膀，他们之间同时生成</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bird</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        wing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Wing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><p><strong>继承/泛化关系（Inheritance/Generalization）</strong>: 用带空心三角形的实线箭头表示，表示一个类继承另一个类的特性和行为。</p></li><li><p><strong>实现关系（Realization）</strong>: 用带空心三角形的虚线箭头表示，表明类实现了接口所定义的契约。</p></li></ul><p><img src="`+p+`" alt="继承和实现"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bird</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WideGoose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IFly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span></code></pre></div><h3 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h3><ul><li><strong>结构可视化</strong>: 显示系统的静态结构，帮助理解系统的组成部分及其相互关系。</li><li><strong>设计沟通</strong>: 作为设计师、开发者之间沟通的工具，确保对系统架构有共同的理解。</li><li><strong>代码生成</strong>: 一些工具可以根据类图自动生成基础的代码框架。</li><li><strong>文档生成</strong>: 类图可以作为项目文档的一部分，帮助维护和理解系统。</li></ul><h2 id="设计模式分类" tabindex="-1">设计模式分类 <a class="header-anchor" href="#设计模式分类" aria-label="Permalink to &quot;设计模式分类&quot;">​</a></h2><h3 id="创建型模式-creational-patterns" tabindex="-1"><strong>创建型模式（Creational Patterns）</strong> <a class="header-anchor" href="#创建型模式-creational-patterns" aria-label="Permalink to &quot;**创建型模式（Creational Patterns）**&quot;">​</a></h3><p>创建型模式关注的是对象的创建过程，旨在隐藏创建逻辑、控制对象的创建方式，以及使系统独立于如何创建、组合和表示对象。这类模式让程序中的对象实例化过程更加灵活、可控制和易于管理。创建型模式包括：</p><ul><li><a href="/justin/docs/method/dp/单例模式.html">单例模式（Singleton）</a></li><li><a href="/justin/docs/method/dp/工厂模式.html">工厂模式（Factory Method）</a></li><li><a href="/justin/docs/method/dp/建造者模式.html">建造者模式（Builder）</a></li><li><a href="/justin/docs/method/dp/原型模式.html">原型模式（Prototype）</a></li></ul><h3 id="结构型模式-structural-patterns" tabindex="-1"><strong>结构型模式（Structural Patterns）</strong> <a class="header-anchor" href="#结构型模式-structural-patterns" aria-label="Permalink to &quot;**结构型模式（Structural Patterns）**&quot;">​</a></h3><p>结构型模式关注的是如何组合类和对象以形成更大的结构，同时保证结构的灵活、高效和易于理解。它们通过封装、组合及代理等方式简化系统结构，使其更易于维护。结构型模式包括：</p><ul><li><a href="/justin/docs/method/dp/适配器模式.html">适配器模式（Adapter）</a></li><li><a href="/justin/docs/method/dp/桥接模式.html">桥接模式（Bridge）</a></li><li><a href="/justin/docs/method/dp/装饰器模式.html">装饰器模式（Decorator）</a></li><li><a href="/justin/docs/method/dp/组合模式.html">组合模式（Composite）</a></li><li><a href="/justin/docs/method/dp/外观模式.html">外观模式（Facade）</a></li><li><a href="/justin/docs/method/dp/享元模式.html">享元模式（Flyweight）</a></li><li><a href="/justin/docs/method/dp/代理模式.html">代理模式（Proxy）</a></li></ul><h3 id="行为型模式-behavioral-patterns" tabindex="-1"><strong>行为型模式（Behavioral Patterns）</strong> <a class="header-anchor" href="#行为型模式-behavioral-patterns" aria-label="Permalink to &quot;**行为型模式（Behavioral Patterns）**&quot;">​</a></h3><p>行为型模式关注的是对象之间的职责分配以及它们之间的通信方式，用于描述在特定场景下对象之间如何交互和协作。这类模式定义了对象之间的责任分配和算法的组织方式，以达到特定的行为目的。行为型模式包括：</p><ul><li><a href="/justin/docs/method/dp/责任链模式.html">责任链模式（Chain of Responsibility）</a></li><li><a href="/justin/docs/method/dp/命令模式.html">命令模式（Command）</a></li><li><a href="/justin/docs/method/dp/解释器模式.html">解释器模式（Interpreter）</a></li><li><a href="/justin/docs/method/dp/迭代器模式.html">迭代器模式（Iterator）</a></li><li><a href="/justin/docs/method/dp/中介者模式.html">中介者模式（Mediator）</a></li><li><a href="/justin/docs/method/dp/备忘录模式.html">备忘录模式（Memento）</a></li><li><a href="/justin/docs/method/dp/观察者模式.html">观察者模式（Observer）</a></li><li><a href="/justin/docs/method/dp/状态模式.html">状态模式（State）</a></li><li><a href="/justin/docs/method/dp/策略模式.html">策略模式（Strategy）</a></li><li><a href="/justin/docs/method/dp/模板方法模式.html">模板方法模式（Template Method）</a></li><li><a href="/justin/docs/method/dp/访问者模式.html">访问者模式（Visitor）</a></li></ul><div class="danger custom-block"><p class="custom-block-title">推荐书籍</p><p>《设计模式：可复用面向对象软件的基础》是设计模式领域的经典之作。</p><p>《Head First设计模式》：这本书以其独特的教学风格，通过图像、故事和实践例子，让设计模式的学习变得生动有趣，特别适合初学者。</p><p>《大话设计模式》：适合中文读者，以轻松幽默的语言讲解设计模式，使用C#作为示例语言，（我看的是Java溢彩加强版）。</p><p>《设计模式之禅》：深入浅出地介绍了多种设计模式，并提供了丰富的Java实战经验，适合有一定编程基础的读者。</p><p>《研磨设计模式》：内容严谨，注重实战，也是使用Java语言来阐述设计模式的运用。</p><p>《设计模式解析》：表述清晰易懂，提供完整的Java示例，是面向对象设计和学习模式的好选择。</p><p>《敏捷软件开发：原则、模式与实践》：结合敏捷开发、极限编程(XP)、面向对象编程(OOP)和设计模式，适合希望在敏捷环境中应用设计模式的开发者。</p><p>《Java与模式》：通过Java语言讲解设计模式，内容丰富且语言生动，有助于加深对Java标准库的理解。</p></div>`,47),d=[o];function k(g,c,u,m,E,y){return a(),i("div",null,d)}const A=s(r,[["render",k]]);export{F as __pageData,A as default};
