import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.Dcf-1z4i.js";const c=JSON.parse('{"title":"函数编程（Lambda）","description":"","frontmatter":{},"headers":[],"relativePath":"docs/java/newfeatures/java8/Java8-Lambda.md","filePath":"docs/java/newfeatures/java8/Java8-Lambda.md","lastUpdated":1716175955000}'),t={name:"docs/java/newfeatures/java8/Java8-Lambda.md"},l=n(`<h1 id="函数编程-lambda" tabindex="-1">函数编程（Lambda） <a class="header-anchor" href="#函数编程-lambda" aria-label="Permalink to &quot;函数编程（Lambda）&quot;">​</a></h1><h2 id="面向对象编程-oop-与函数式编程-fp" tabindex="-1">面向对象编程（OOP）与函数式编程（FP） <a class="header-anchor" href="#面向对象编程-oop-与函数式编程-fp" aria-label="Permalink to &quot;面向对象编程（OOP）与函数式编程（FP）&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">面向对象和函数式编程</p><blockquote><p>面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。</p></blockquote></div><p>Java作为一种面向对象编程语言，传统上强调通过对象来解决问题。然而，自Java 8引入Lambda表达式后，Java也开始支持函数式编程，使得Java不仅支持OOP，还支持函数式编程（FP）。</p><ul><li><p><strong>OOP</strong>：在OOP中，解决问题的思路是通过找到一个能解决这个问题的对象，并调用该对象的方法来完成任务。</p></li><li><p><strong>FP</strong>/OOF：在FP中，关注的是结果而不是过程。只要能够得到结果，谁来做的，怎么做的并不重要。在FP中，我们更关心的是如何通过函数的组合和应用来获得结果，而不是通过对象的方法来实现。</p></li></ul><h2 id="匿名内部类" tabindex="-1">匿名内部类 <a class="header-anchor" href="#匿名内部类" aria-label="Permalink to &quot;匿名内部类&quot;">​</a></h2><p>匿名内部类在Java中是一种方便的语法，可以用来快速定义并创建一个接口或抽象类的实例。然而，它们也有一些显著的缺点，这些缺点正是引入Lambda表达式的动因之一</p><ol><li><p><strong>冗长和复杂的语法</strong>： 匿名内部类需要写大量的样板代码，包括类声明、构造方法和接口方法的实现。这些代码往往很冗长，使得代码难以阅读和维护。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Runnable runnable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;运行一个匿名内部类&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(runnable).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li><li><p><strong>可读性差</strong>： 由于匿名内部类的语法过于冗长，当我们需要定义简单的行为时，代码的可读性会大大降低。特别是在需要多次使用匿名内部类的情况下，代码显得非常混乱。</p></li><li><p><strong>灵活性不足</strong>： 匿名内部类只能用于有名称的类或接口实现，不适用于方法或表达式，使得某些情况下的代码</p></li></ol><h2 id="lambda表达式的引入" tabindex="-1">Lambda表达式的引入 <a class="header-anchor" href="#lambda表达式的引入" aria-label="Permalink to &quot;Lambda表达式的引入&quot;">​</a></h2><p>为了克服匿名内部类的这些缺点，Lambda表达式(又称<strong>闭包</strong>或<strong>匿名函数</strong>)是Java 8引入的一个新特性，它允许将函数作为参数传递，使代码更简洁和可读。Lambda表达式主要用于替代匿名内部类，特别是在需要实现单一抽象方法的场景中。</p><h3 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h3><p>Lambda表达式的基本语法形式如下：</p><ul><li>左侧： Lambda 表达式参数列表</li><li>右侧： Lambda 体，是抽象方法的实现，即 Lambda 表达式要执行的功能。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameters) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expression</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">或</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameters) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { statements; }</span></span></code></pre></div><h3 id="详细语法" tabindex="-1">详细语法 <a class="header-anchor" href="#详细语法" aria-label="Permalink to &quot;详细语法&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//1、无参数，无返回值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;lambda&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//2、单参数，无返回值(省略参数小括号)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Consumer&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; consumer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//3、多参数，有返回值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Comparator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; comparator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x, y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//4、多参数，有返回值，带代码块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BinaryOperator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; add </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Result: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//5、单条语句，省略return和大括号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BinaryOperator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; multiply </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span></code></pre></div><h3 id="类型推断" tabindex="-1">类型推断 <a class="header-anchor" href="#类型推断" aria-label="Permalink to &quot;类型推断&quot;">​</a></h3><p>Lambda表达式中的参数类型可以由编译器根据上下文推断出来，无需显式声明。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 带有显式类型的Lambda表达式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Comparator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; comparator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Integer x, Integer y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用类型推断</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Comparator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; comparator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x, y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y);</span></span></code></pre></div><h2 id="函数式-functional-接口" tabindex="-1">函数式(Functional)接口 <a class="header-anchor" href="#函数式-functional-接口" aria-label="Permalink to &quot;函数式(Functional)接口&quot;">​</a></h2><h3 id="简单介绍" tabindex="-1">简单介绍 <a class="header-anchor" href="#简单介绍" aria-label="Permalink to &quot;简单介绍&quot;">​</a></h3><p>Lambda表达式只能用于函数式接口，这些接口有且仅有一个抽象方法。函数式接口可以通过<code>@FunctionalInterface</code>注解来显式声明，但即使没有这个注解，只要接口符合条件，编译器也会自动识别它为函数式接口。常见的函数式接口包括<code>Runnable</code>、<code>Callable</code>、<code>Comparator</code>，以及位于<code>java.util.function</code>包中的<code>Predicate</code>、<code>Function</code>、<code>Consumer</code>、<code>Supplier</code>等。</p><h3 id="常见函数式接口" tabindex="-1">常见函数式接口 <a class="header-anchor" href="#常见函数式接口" aria-label="Permalink to &quot;常见函数式接口&quot;">​</a></h3><table><thead><tr><th>函数式接口</th><th>称谓</th><th>参数类型</th><th>用途</th></tr></thead><tbody><tr><td><code>Consumer&lt;T&gt; </code></td><td>消费型接口</td><td>T</td><td>对类型为T的对象应用操作，包含方法： <code>void accept(T t) </code></td></tr><tr><td><code>Supplier&lt;T&gt; </code></td><td>供给型接口</td><td>无</td><td>返回类型为T的对象，包含方法：<code>T get() </code></td></tr><tr><td><code>Function&lt;T, R&gt; </code></td><td>函数型接口</td><td>T</td><td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t) </code></td></tr><tr><td><code>Predicate&lt;T&gt; </code></td><td>判断型接口</td><td>T</td><td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t) </code></td></tr></tbody></table><h3 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h3><p>在函数式编程范式里，&quot;函数作为一等公民&quot;意味着函数可以被赋值给变量、作为参数传递给其他函数、从其他函数返回，就像对待基本数据类型（如整数、字符串）一样自由。在这种环境下，Lambda表达式直接代表函数本身，拥有函数的特性。</p><p>然而，在Java 8中，情况略有不同，尽管Lambda表达式引入了函数式编程的特性，但它们在Java中不是直接作为“函数”存在的。具体来说：</p><details class="details custom-block"><summary><strong>Lambda表达式视为对象</strong></summary><p>在Java 8中，Lambda表达式实际上是对象的实例，而非纯粹的函数。这一点区别于某些其他函数式编程语言直接将Lambda视为函数类型。</p></details><details class="details custom-block"><summary><strong>函数式接口的必要性</strong></summary><p>Java中的Lambda表达式需要基于一个被称为“函数式接口”的特定类型。函数式接口是指只有一个抽象方法的接口（加上默认方法和静态方法）。这样的接口定义了Lambda表达式的行为规范。换句话说，Lambda表达式是用来实现这类接口中唯一抽象方法的具体实现。</p></details><details class="details custom-block"><summary><strong>关系概括</strong></summary><p>因此，在Java 8及以后版本中，Lambda表达式实质上是函数式接口的一个实例化形式。当你定义一个Lambda表达式时，编译器会自动将其匹配到合适的函数式接口上。这意味着，任何可以用Lambda表达式表示的逻辑，本质上都是在实现一个函数式接口的抽象方法。</p></details><p>简而言之，Java通过函数式接口作为桥梁，使得Lambda表达式能够以一种类型安全的方式扮演函数的角色，即使它们在Java中底层表现为对象。这种设计既保留了Java的静态类型系统特性，又引入了函数式编程的便捷和灵活性。</p><h2 id="方法引用" tabindex="-1">方法引用 <a class="header-anchor" href="#方法引用" aria-label="Permalink to &quot;方法引用&quot;">​</a></h2><p><strong>方法引用</strong>是Lambda表达式的简洁替代形式，用于引用已有方法，其实质仍然是函数式接口的实例。当操作可通过现有方法实现时，使用<code>ClassOrInstance::methodName</code>语法，无需显式编写Lambda，从而提高代码的清晰度和简洁性。这种方法引用机制是对Lambda的一种优化，或称为“语法糖”。</p><h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h3><ul><li><p><strong>格式</strong>:使用方法引用操作符 “<code>::</code>” 将类(或对象) 与 方法名分隔开来。</p></li><li><p><strong>分类</strong></p><ul><li><strong>静态方法引用</strong>: 当你想要引用一个静态方法时，格式为 <code>ClassName::staticMethodName</code>。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; parseInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parseInt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//等同于：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; parseInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span></code></pre></div><ul><li><strong>实例方法引用</strong>: 当引用一个对象的实例方法，并且该对象是函数式接口参数的一部分时，格式为 <code>ClassName::methodName</code>。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BiPredicate&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; equalsIgnoreCase </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">equalsIgnoreCase;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//等同于：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BiPredicate&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; equalsIgnoreCase </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (str1, str2) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equalsIgnoreCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str2);</span></span></code></pre></div><ul><li><strong>特定对象的实例方法引用</strong>: 如果你有一个特定对象，并且想要引用它的实例方法，格式为 <code>instance::methodName</code>。但是，这种形式较为少见，因为通常我们直接调用实例方法就足够了。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Supplier&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; stringSupplier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">toUpperCase;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//等同于：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Supplier&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; stringSupplier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li></ul><h2 id="构造器引用" tabindex="-1">构造器引用 <a class="header-anchor" href="#构造器引用" aria-label="Permalink to &quot;构造器引用&quot;">​</a></h2><p><strong>构造器引用</strong>是方法引用的一个特例，专门用于引用类的构造函数。其语法 <code>ClassName::new</code>，与类构造器引用相同。构造器引用主要用于与函数式接口（如<code>Supplier</code>、<code>Function</code>、<code>BiFunction</code>等）结合使用，以更简洁地创建和初始化对象。</p><h3 id="使用-1" tabindex="-1">使用 <a class="header-anchor" href="#使用-1" aria-label="Permalink to &quot;使用&quot;">​</a></h3><ul><li><strong>超类构造器引用</strong>: 通过 <code>super::new</code> 引用超类构造器，实际应用中更多见于内部类构造器引用。</li><li><strong>类构造器引用</strong>: 格式为 <code>ClassName::new</code>,它引用了一个类的构造方法，常用于创建对象的场景。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//无参构造器</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//语法：ClassName::new</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Supplier&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; personSupplier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//等同于：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Supplier&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; personSupplier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//带参构造器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; personCreator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//等同于：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; personCreator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name);</span></span></code></pre></div>`,40),h=[l];function p(k,e,r,d,E,g){return a(),i("div",null,h)}const y=s(t,[["render",p]]);export{c as __pageData,y as default};
